#! /usr/bin/perl

# Add/remove key=value pairs from iso application area (0x200 bytes at
# 0x8373). Entries are separated by semicolons ';'.
#
# digest is calculated assuming all zeros in 0x0000-0x01ff (MBR) and all
# spaces in 0x8373-0x8572.

use strict;

use Getopt::Long;
use Digest::MD5;
use Digest::SHA;

sub usage;
sub read_image_start;
sub get_image_type;
sub get_tags;
sub prepare_buffer;
sub add_to_digest;

my $opt_digest = undef;
my $opt_check = 0;
my $opt_pad = undef;
my $opt_show = 1;
my $opt_clean = 0;
my @opt_add_tag;
my @opt_remove_tag;

GetOptions(
  'show'             => \$opt_show,
  'md5|md5sum'       => sub { $opt_digest = 'md5' },
  'digest=s'         => \$opt_digest,
  'check'            => \$opt_check,
  'pad=i'            => \$opt_pad,
  'add-tag=s'        => \@opt_add_tag,
  'remove-tag=s'     => \@opt_remove_tag,
  'clean'            => \$opt_clean,
  'help'             => sub { usage 0 },
);

# Note: all size variables use 0.5 kB units!

my $buf0;
my $buf0_size = 0x9000 / 512;
my $digest_iso;
my $digest_part;
my $image_name;
my $image_fh;
my $write_image;
my $image_type;
my $type_iso;
my $iso_size;
my $pad_size;
my $part_start;
my $part_size;
my $tags;
my %new_tags;
my @old_tags;
my %rtags;
my @tags;
my $new_tags;

if($opt_digest =~ /^md5(sum)?$/i) {
  $digest_iso = Digest::MD5->new;
  $digest_part = Digest::MD5->new;
}
elsif($opt_digest =~ /^sha(1|224|256|384|512)(sum)?$/i) {
  $digest_iso = Digest::SHA->new($1);
  $digest_part = Digest::SHA->new($1);
}
elsif($opt_digest) {
  die "$opt_digest: unsupported digest\n";
}

$write_image = $opt_digest || defined $opt_pad || $opt_check || @opt_add_tag || @opt_remove_tag || $opt_clean;

$image_name = shift;

usage 1 if $image_name eq '';

read_image_start;
get_image_type;
get_tags;
prepare_buffer;

unshift @opt_add_tag, "check=1" if $opt_check;

# in 0.5 kB
$pad_size = $opt_pad << 2;

if(defined $opt_pad) {
  if($opt_pad) {
    # add pad tag
    unshift @opt_add_tag, "pad=$opt_pad";
    if($pad_size >= $iso_size) {
      die "$opt_pad: padding too big!\n";
    }
    $iso_size -= $pad_size;
  }
  else {
    # clear pad tag
    unshift @opt_remove_tag, "pad"
  }
}

# calculate digest
if($opt_digest) {
  $digest_iso->add($buf0);

  # Note: $iso_pad has been subtracted from $iso_size!

  my $next_stop = $iso_size;
  my $idx = $buf0_size;

  my $iso_rem;
  my $part_rem;

  if($part_start) {
    add_to_digest $part_start - $buf0_size, 1, 0;
    $idx = $part_start;

    $next_stop = $part_start + $part_size;
    $next_stop = $iso_size if $iso_size < $next_stop;

    $part_rem = $part_start + $part_size - $next_stop;
  }

  add_to_digest $next_stop - $idx, 1, 1;

  $iso_rem = $iso_size - $next_stop;

  if($part_rem) {
    die "oops, assumption failed\n" if $iso_rem;
    add_to_digest $part_rem, 0, 1;
  }
  else {
    die "oops, assumption failed\n" if $part_rem;
    add_to_digest $iso_rem, 1, 0;
  }

  my $buf = "\x00" x 0x200;
  while($pad_size-- > 0) {
    $digest_iso->add($buf);
  }

  $digest_iso = $digest_iso->hexdigest;
  $digest_part = $digest_part->hexdigest;

  unshift @opt_add_tag, "${opt_digest}sum=$digest_iso";
  unshift @opt_add_tag, "partition=$part_start,$part_size,$digest_part" if $part_size;
}

close $image_fh;

# replace existing tags
for (@opt_add_tag) {
  $new_tags{$1} = 1 if /^(\S+?)\s*=/;
}

# use old tags unless 'clean' option was given
if(!$opt_clean) {
  for (split /;/, $tags) {
    s/^\s*|\s*$//g;
    push @old_tags, "$_" unless $_ eq "" || (/^(\S+?)\s*=/ && $new_tags{$1});
  }
}

# print "OLD ", @old_tags, "\n";

# remove tags
$rtags{$_} = 1 for @opt_remove_tag;
for (@old_tags, @opt_add_tag) {
  push @tags, $_ unless $_ eq "" || (/^(\S+?)\s*=/ && $rtags{$1}) ;
}

$new_tags = join ';', @tags;
die "too many tags: \"$new_tags\"\n" if length($new_tags) > 0x200;
$new_tags .= " " x (0x200 - length($new_tags));

if($write_image) {
  my $len;

  die "$image_name: $!\n" unless open $image_fh, "+<$image_name";
  die "$image_name: $!\n" unless seek $image_fh, 0x8373, 0;
  die "$image_name: $!\n" unless $len = syswrite $image_fh, $new_tags, 0x200;
  die "$image_name: file too short\n" unless $len == 0x200;
  close $image_fh;
}

print "$_\n" for $write_image ? @tags : @old_tags;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# usage(exit_code)
#
# Print help message and exit program with exit_code.
#
sub usage
{
  (my $msg = <<"  = = = = = = = =") =~ s/^ {4}//mg;
    Usage: tagmedia [OPTIONS] IMAGE
    Add/remove tags to SUSE installation media.

    IMAGE is an SUSE installation medium; either DVD image or disk image.

    Options:

      --show                    Show currently set tags (default if no option is given).
      --digest DIGEST           Add digest DIGEST (md5, sha1, sha224, sha256, sha384, sha512).
      --pad N                   Ignore N 2 kB blocks of padding (at image end).
      --check                   Tell installer to run media check at startup.
      --add-tag foo=bar         Add tag foo with value bar.
      --remove-tag foo          Remove tag foo.
      --clean                   Remove all tags.
      --help                    Write this help text.

  = = = = = = = =

  print $msg;

  exit shift;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# read_image_start()
#
# Read first 1 MB.
#
sub read_image_start
{
  die "$image_name: $!\n" unless open $image_fh, $image_name;
  die "$image_name: $!\n" unless sysread $image_fh, $buf0, $buf0_size << 9;
  die "$image_name: file too short\n" if $buf0_size << 9 != length $buf0;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# get_image_type()
#
sub get_image_type
{
  # get size from iso9660 header
  # sets $iso_size (in 0.5 kB units)
  if(substr($buf0, 0x8000, 7) eq "\x01CD001\x01") {
    $iso_size = 4 * unpack("V", substr($buf0, 0x8050, 4));
  }

  # scan mbr for biggest partition
  # sets $part_start, $part_size (in 0.5 kB units)
  if(substr($buf0, 0x1fe, 2) eq "\x55\xaa") {
    for (my $idx = 0; $idx < 4; $idx++) {
      my ($boot, $type, $start, $size) = unpack("Cx3Cx3VV", substr($buf0, 0x1be + 0x10 * $idx, 0x10));
      if(($boot & 0x7f) == 0 && $type != 0) {
        if($size > $part_size) {
          $part_start = $start;
          $part_size = $size;
        }
      }
    }
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# get_tags()
#
sub get_tags
{
  $tags = substr($buf0, 0x8373, 0x200);
  die "$image_name: unsupported image format\n" unless $tags =~ /^[0-9A-Za-z_=,; \x00]{512}$/;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# prepare_buffer()
#
sub prepare_buffer
{
  substr($buf0, 0x0000, 0x200) = "\x00" x 0x200;
  substr($buf0, 0x8373, 0x200) = " " x 0x200;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# add_to_digest(blocks, to_iso, to_part)
#
sub add_to_digest
{
  my ($blocks, $to_iso, $to_part) = @_;

  my $buf;

  while($blocks > 0) {
    # try to read up to 1 MB at a time
    my $len = $blocks > (1 << 11) ? 1 << 11 : $blocks;
    my $read_len = sysread $image_fh, $buf, $len << 9;
    die "$image_name: read error\n" if $read_len != $len << 9;
    $digest_iso->add($buf) if $to_iso;
    $digest_part->add($buf) if $to_part;
    $blocks -= $len;
  }
}
