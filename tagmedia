#! /usr/bin/perl

# Add/remove key=value pairs from iso application area (0x200 bytes starting
# at 0x8373). Entries are separated by semicolons (';').
#
# Digest is calculated assuming all zeros in 0x0000-0x01ff (MBR) and all
# spaces in 0x8373-0x8572.

use strict;

use Getopt::Long;
use Digest::MD5;
use Digest::SHA;

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 1;

sub usage;
sub read_image_blob;
sub get_image_type;
sub get_padding;
sub read_tags;
sub write_tags;
sub parse_tag;
sub get_tag;
sub set_tag;
sub remove_tag;
sub prepare_buffer;
sub add_to_digest;
sub calculate_digest;

my $opt_digest = undef;
my $opt_check = 0;
my $opt_pad = undef;
my $opt_show = 1;
my $opt_clean = 0;
my @opt_add_tag;
my @opt_remove_tag;

GetOptions(
  'show'             => \$opt_show,
  'md5|md5sum'       => sub { $opt_digest = 'md5' },
  'digest=s'         => \$opt_digest,
  'check'            => \$opt_check,
  'pad=i'            => \$opt_pad,
  'add-tag=s'        => \@opt_add_tag,
  'remove-tag=s'     => \@opt_remove_tag,
  'clean'            => \$opt_clean,
  'help'             => sub { usage 0 },
);

my $image_data;			# hash ref with image related data
my $current_tags = [];		# current list of tags
my $old_tags = [];		# original list of tags
my $digest_iso;			# digest calculated over iso image
my $digest_part;		# digest calculated over partition

# Note: all '*_block' variables use 0.5 kB units.


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$image_data->{name} = shift;
usage 1 if $image_data->{name} eq '';

$image_data->{write} = $opt_digest || defined $opt_pad || $opt_check || @opt_add_tag || @opt_remove_tag || $opt_clean;

if($opt_digest =~ /^md5(sum)?$/i) {
  $digest_iso = Digest::MD5->new;
  $digest_part = Digest::MD5->new;
}
elsif($opt_digest =~ /^sha(1|224|256|384|512)(sum)?$/i) {
  $digest_iso = Digest::SHA->new($1);
  $digest_part = Digest::SHA->new($1);
}
elsif($opt_digest) {
  die "$opt_digest: unsupported digest\n";
}

read_image_blob $image_data;
get_image_type $image_data;

$old_tags = read_tags $image_data unless $opt_clean;

# clone tag list
set_tag $current_tags, { key => $_->{key}, value =>  $_->{value} } for @$old_tags;

for (@opt_remove_tag) {
  $current_tags = remove_tag $current_tags, $_;
}

set_tag $current_tags, { key => "check", value => 1 } if $opt_check;

get_padding $image_data, $current_tags;
#set_tag $current_tags, { key => "isosize", value => ($image_data->{iso_blocks} + $image_data->{pad_blocks})/4 };

prepare_buffer $image_data;

# print Dumper $image_data;
# print Dumper $current_tags;

# calculate digest
calculate_digest $image_data if $opt_digest;

# finally close file handle (had been opened in read_image_blob())
close $image_data->{fh};

write_tags $image_data, $current_tags if $image_data->{write};

# print tags for user's pleasure
for (@{$image_data->{write} ? $current_tags : $old_tags}) {
  print "$_->{key}";
  print " = $_->{value}" if defined $_->{value};
  print "\n";
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# usage(exit_code)
#
# Print help message and exit program with exit_code.
#
sub usage
{
  (my $msg = <<"  = = = = = = = =") =~ s/^ {4}//mg;
    Usage: tagmedia [OPTIONS] IMAGE
    Add/remove tags to SUSE installation media.

    IMAGE is an SUSE installation medium; either DVD image or disk image.

    Options:

      --show                    Show currently set tags (default if no option is given).
      --digest DIGEST           Add digest DIGEST (md5, sha1, sha224, sha256, sha384, sha512).
      --pad N                   Ignore N 2 kB blocks of padding (at image end).
      --check                   Tell installer to run media check at startup.
      --add-tag foo=bar         Add tag foo with value bar.
      --remove-tag foo          Remove tag foo.
      --clean                   Remove all tags.
      --help                    Write this help text.

  = = = = = = = =

  print $msg;

  exit shift;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# read_image_blob(image)
#
# Read first 36 kB.
# Note: leaves $image_data ->{fh} open for calculate_digest() to continue reading.
#
# image: hash with image related data
#
sub read_image_blob
{
  my ($image) = @_;

  my $blob_size = 0x9000;
  $image->{blob_blocks} = $blob_size >> 9;		# in 0.5 kB units

  die "$image->{name}: $!\n" unless open $image->{fh}, $image->{name};
  die "$image->{name}: $!\n" unless sysread $image->{fh}, $image->{blob}, $blob_size;
  die "$image->{name}: file too short\n" if $blob_size != length $image->{blob};
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# get_image_type(image)
#
# Analyze image type and get some basic data.
#
# image: hash with image related data
# image->{blob}: buffer containing a sufficiently large portion of the image (36 kB)
#
sub get_image_type
{
  my ($image) = @_;

  # Get iso size from iso9660 header.
  #
  # Don't verify too much - most of the header might be gone. Checking for
  # plausible size info should be enough.
  #
  my $little = 4 * unpack("V", substr($image->{blob}, 0x8050, 4));
  my $big = 4 * unpack("N", substr($image->{blob}, 0x8054, 4));
  if(
    $little &&
    $little == $big &&
    $little <= (-s $image->{name}) / 512
  ) {
    $image->{iso_blocks} = $little;
  }

  # Scan mbr for last primary partition.
  #
  # Set $image->{part_start}, $image->{part_blocks} (in 0.5 kB units).
  #
  if(substr($image->{blob}, 0x1fe, 2) eq "\x55\xaa") {
    for (my $idx = 0; $idx < 4; $idx++) {
      my ($boot, $type, $start, $size) = unpack("Cx3Cx3VV", substr($image->{blob}, 0x1be + 0x10 * $idx, 0x10));
      if(
        $type &&
        !($boot & 0x7f) &&
        $size &&
        $start + $size > $image->{part_start} + $image->{part_blocks}
      ) {
        $image->{part_start} = $start;
        $image->{part_blocks} = $size;
      }
    }
  }

  die "$image->{name}: unsupported image format\n" unless $image->{iso_blocks} || $image->{part_blocks};
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# get_padding(image, tags)
#
# Get padding value to use.
#
# image: hash with image related data
# tags: array ref with tag hashes
#
sub get_padding
{
  my ($image, $tags) = @_;
  my $padding_set;

  if($image->{iso_blocks}) {
    set_tag $tags, { key => "pad", value => $opt_pad } if $opt_pad;
    my $pad_tag = get_tag $tags, "pad";

    $image->{pad_blocks} = $pad_tag->{value} << 2 if $pad_tag;
    $image->{iso_blocks} -= $image->{pad_blocks};

    die "padding too large\n" if $image->{iso_blocks} <= 0;
  }
  else {
    remove_tag $tags, "pad";
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# tags = read_tags(image)
#
# Read existing tags from image fragment.
#
# image: hash with image related data
# image->{blob}: buffer containing a sufficiently large portion of the image (36 kB)
# tags: array ref with tags
# tags are hashes with key/value pairs - value is undef if there's no '='
#
sub read_tags
{
  my ($image) = @_;

  my $buf = substr($image->{blob}, 0x8373, 0x200);
  die "$image->{name}: unsupported image format\n" unless $buf  =~ /^[0-9A-Za-z_=,;! \x00]{512}$/;
  $buf =~ s/[\s\x00]*$//;

  my $tags = [];

  for my $line (split /;/, $buf) {
    set_tag $tags, parse_tag($line);
  }

  return $tags;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# write_tags(image, $tags)
#
# Insert tags into image fragment.
# Note: this does not write anything to disk!
#
# image: hash with image related data
# image->{blob}: buffer containing a sufficiently large portion of the image (36 kB)
# tags: array ref with tags
#
sub write_tags
{
  my ($image, $tags) = @_;
  my $buf;

  for my $tag (@$tags) {
    $buf .= ";" if defined $buf;
    $buf .= $tag->{key};
    $buf .= "=$tag->{value}" if defined $tag->{value};
  }

  die "tags too large: \"$buf\"\n" if length($buf) > 0x200;
  $buf .= " " x (0x200 - length($buf));

  my $len;
  die "$image->{name}: $!\n" unless open $image->{fh}, "+<", $image->{name};
  die "$image->{name}: $!\n" unless seek $image->{fh}, 0x8373, 0;
  die "$image->{name}: $!\n" unless $len = syswrite $image->{fh}, $buf, 0x200;
  die "$image->{name}: failed to update image\n" unless $len == 0x200;

  close $image->{fh};
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# tag = parse_tag(string)
#
# Parse line ('key=value' format) and return hash ref with key/value elements.
# value is undef if there's no '='.
#
sub parse_tag
{
  my ($line) = @_;

  $line =~ s/^\s*|\s*$//g;

  if($line =~ /^([A-Z_\d\s]+?)\s*=\s*+(.*)$/i) {
    return { key => $1, value => $2 };
  }
  else {
    return { key => $line };
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# tag = get_tag(tags, key)
#
# Get tag from tag array with specified key.
# Returns undef if no tag with such a key exists.
#
# tags: array ref with tag hashes
# key: string
# tag: tag hash ref ('key', 'value' pair)
#
sub get_tag
{
  my ($tags, $key) = @_;

  for my $tag (@$tags) {
    return $tag if $tag->{key} eq $key;
  }

  return undef;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# set_tag(tags, tag)
#
# Set tag in tags array.
#
# tags: array ref with tag hashes
# tag: tag hash ref ('key', 'value' pair)
#
sub set_tag
{
  my ($tags, $tag) = @_;

  my $old_tag = get_tag $tags, $tag->{key};
  if($old_tag) {
    $old_tag->{value} = $tag->{value};
  }
  else {
    push @$tags, $tag;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# tags = remove_tag(tags, key)
#
# Remove tag from tag array with specified key.
# Returns new tag array.
#
# tags: array ref with tag hashes
# key: string
#
sub remove_tag
{
  my ($tags, $key) = @_;
  my @l;

  return [ grep { $_->{key} ne $key } @$tags ];
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# prepare_buffer(image)
#
# Reset some areas in image blob to defined values before starting digest calculation.
#
# image: hash with image related data
# image->{blob}: buffer containing a sufficiently large portion of the image (36 kB)
#
sub prepare_buffer
{
  my $image = $_[0];

  substr($image->{blob}, 0x0000, 0x200) = "\x00" x 0x200;
  substr($image->{blob}, 0x8373, 0x200) = " " x 0x200;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# add_to_digest(image, blocks, to_iso, to_part)
#
# Update digest reading blocks from $image->{fh}.
#
# blocks: number of blocks to read
# to_iso: update $digest_iso
# to_part: update $digest_part
#
# Note: a block is 0.5 kB.
#
sub add_to_digest
{
  my ($image, $blocks, $to_iso, $to_part) = @_;

  my $buf;

  while($blocks > 0) {
    # try to read up to 1 MB at a time
    my $len = $blocks > (1 << 11) ? 1 << 11 : $blocks;
    my $read_len = sysread $image->{fh}, $buf, $len << 9;
    die "$image->{name}: read error\n" if $read_len != $len << 9;
    $digest_iso->add($buf) if $to_iso && $image->{iso_blocks};
    $digest_part->add($buf) if $to_part && $image->{part_blocks};
    $blocks -= $len;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# calculate_digest($image)
#
# Calculate digest.
#
# Note: $image_data->{fh} has been opened in read_image_blob(). We just continue
# reading here.
#
# This function calculates 2 different digests:
#
#   (1) $image->{iso_blocks} starting from 0, plus $image->{pad_blocks} of zeros
#   (2) $image->{part_blocks} starting from $image->{part_start}
#
# $image->{blob_blocks} have already been read and are cached in $image->{blob}.
#
# Both regions partly overlap and region 2 can overlap $image->{blob}.
#
# This function makes some effort to read the file in only one go.
#
# Note: padding has been subtracted from $image->{iso_blocks}.
#
sub calculate_digest
{
  my ($image) = @_;

  $digest_iso->add($image->{blob}) if $image->{iso_blocks};

  my $next_stop = $image->{iso_blocks};
  my $idx = $image->{blob_blocks};

  my $iso_rem;
  my $part_rem;

  if($image->{part_start}) {
    if($image->{part_start} < $image->{blob_blocks}) {
      $digest_part->add(
        substr($image->{blob}, $image->{part_start} << 9, ($image->{blob_blocks} - $image->{part_start}) << 9)
      );
      $idx = $image->{blob_blocks};
    }
    else {
      add_to_digest $image, $image->{part_start} - $image->{blob_blocks}, 1, 0;
      $idx = $image->{part_start};
    }

    $next_stop = $image->{part_start} + $image->{part_blocks};
    $next_stop = $image->{iso_blocks} if $image->{iso_blocks} && $image->{iso_blocks} < $next_stop;

    $part_rem = $image->{part_start} + $image->{part_blocks} - $next_stop;
  }

  add_to_digest $image, $next_stop - $idx, 1, 1;

  $iso_rem = $image->{iso_blocks} - $next_stop if $image->{iso_blocks};

  if($part_rem) {
    die "oops, assumption failed\n" if $iso_rem;
    add_to_digest $image, $part_rem, 0, 1;
  }
  elsif($iso_rem) {
    add_to_digest $image, $iso_rem, 1, 0;
  }

  if($image->{iso_blocks}) {
    my $buf = "\x00" x 0x200;
    my $pad_blocks = $image->{pad_blocks};

    while($pad_blocks-- > 0) {
      $digest_iso->add($buf);
    }

    $digest_iso = $digest_iso->hexdigest;
    set_tag $current_tags, { key => "${opt_digest}sum", value => $digest_iso };
  }

  if($image->{part_blocks}) {
    $digest_part = $digest_part->hexdigest;
    set_tag $current_tags, {
      key => "partition",
      value => "$image->{part_start},$image->{part_blocks},$digest_part"
    }
  }
}
